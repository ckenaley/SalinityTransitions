---
title: "Salinity Spatial Analysis"
author: "O'Connor and Kenaley"
date: "6/16/20223"
output: html_document
---

The following will assess halotolerance


```{r setup,echo=FALSE}
library(ggplot2)
library(rgbif)
library(maps)
library(reshape2)
library(plyr)
library(data.table)
library(tidyverse)
library(fishtree)
library(raster)
library(ncdf4)
library(viridis)
library(foreach)
library(doParallel)
library(rgdal)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(rgeos)
library(lwgeom)

```

# GBIF data

## GBIF api

Get data from GBIF. All species in Rabosky tree with FishBase Data.

```{r species}

fb.dat <- readRDS("fishbase.data.RDS")
```

## Query GBIF

```{r gbif, eval=F}

## Takes a long time, but reduced with dopar and foreach

cl <- makePSOCKcluster(detectCores()-2) # leave two cores for background processes
# cl <- makePSOCKcluster(1) # if old PC use only 1 core
registerDoParallel(cl) # register parallel backend
getDoParWorkers() # show number of workers


system.time(
gbif.dat <- foreach(i=rob.tree$tip.label,.verbose=T, .packages = c("data.table", "rgbif")) %dopar% {
    try(
occ_search(scientificName = i, hasCoordinate=T, limit =1000,hasGeospatialIssue = F,basisOfRecord = "PRESERVED_SPECIMEN")$data,silent = T
      )
}
)

  try({gbif.i <- occ_search(scientificName = i, hasCoordinate=T, limit =1000);
      message('\r', paste0(last,"/",max.sp, " species"), appendLF = FALSE)}
      ,silent = T)
  if(!inherits(gbif.i,"try-error")){
    gbif.i <- NA
  }
stopCluster(cl) # stop parallel backend


saveRDS(gbif.dat,"GBIF.data.RDS")
```


## Filter and save

```{r combgbif, eval=FALSE}
gbif.dat <- readRDS("GBIF.data.RDS")


gbif.cols <-c("name","genus","species","acceptedScientificName","scientificName","key","decimalLatitude","decimalLongitude","speciesKey","depth","depthAccuracy","habitat","year","month","day")

g.l <- list() 
for(n in 1:length(gbif.dat)){
  d.n <- gbif.dat[[n]]
  
if(length(d.n)>1){
   null.c <- sapply(gbif.cols,function(x) x %in% colnames(d.n))
   names.c <- names(null.c)[!null.c]
   d.nn <- data.table(d.n)
   d.nnn <- if(length(names.c)>0){d.nn[,c(names.c):=NA]}else(d.nn)
   g.l[[n]] <- d.nnn[,..gbif.cols]
 }else{NA
   
   nulls <- data.table()
   g.l[[n]] <- nulls[,c(gbif.cols):=NA]
     }

}


gbif <- do.call(rbind,g.l)

gbif.sum <- gbif[,.N,by=.(species)]


gbif.sum%>%
  ggplot(aes(x=N))+geom_histogram(binwidth = 50)

saveRDS(gbif,"GBIF.data.table.RDS")
```

Read in data

```{r readgbif}

gbif <- readRDS("GBIF.data.table.RDS")

#reduced for quick ploting
g.red <- gbif%>%
  group_by(scientificName)%>%
  dplyr::summarise(m.lat=mean(decimalLatitude),m.long=mean(decimalLongitude),n=length(decimalLongitude))

```

# Maps

## Establish maps for checking records.

These were used extensively to check for issues in GBIF data and FishBase salinity categories


```{r gbifmap}

world <- map_data("world")

#using maps
world.map <- ggplot(world, aes(long, lat)) 

#using rnaturalearth

world2 <- rnaturalearth::ne_countries(scale = 'small', returnclass = c("sf"))

coast <- rnaturalearth::ne_coastline(scale = 'medium', returnclass = c("sf"))


world.map2 <- ggplot() +
  geom_sf(data = world2, size = .2, fill = "gray80", col = "gray90") +
  theme(panel.grid.major = element_line(color = gray(0.9), linetype = "dashed", size = 0.5))

coast.map <- ggplot() +
  geom_sf(data = coast, size = .3, col = "black") +
  theme(panel.grid.major = element_line(color = gray(0.9), linetype = "dashed", size = 0.5))

world.map+geom_polygon(aes(group = group), fill = "white", color = "gray40", size = .2) + geom_jitter(data = g.red,aes(m.long, m.lat), alpha=0.6, size = 1, color = "red") 
```

# Assessing marine, fresh, or estuarine occurence

## Load marine and estuarine shape files

Chunk below inspired by: https://gist.github.com/jebyrnes/c3733b4d0208cf88012e

Script is modified to use old TNC MEOW data that includes just the 200-m shelf break line. See: https://rstudio-pubs-static.s3.amazonaws.com/485396_7d5f60e87225469fb0c0c04684a0cf31.html#pelagic-provinces-of-the-world-ppow

Using the function below, we can figure out if a record is from over the shelf break or in a pelagic realm. Also used to find TNC major habibat type with a different shape (`feow`)


```{r shapedata}
#Spherical geometry (s2) switched off, otherwise polygon errors
sf_use_s2(FALSE)
#marine shapes
meow <- sf::read_sf("./MEOW_PPOW/01_Data/WCMC-036-MEOW-PPOW-2007-2012.shp") 

#fw shapes

feow <- sf::read_sf("./FEOW-TNC/FEOWv1_TNC.shp")

#simplify for size/time sake
meow2 <- meow %>% 
  sf::st_simplify(dTolerance = 01)

meow2 <- meow2 %>% 
  dplyr::group_by(PROVINC, REALM, TYPE) %>% 
  dplyr::summarise()

object.size(meow)
object.size(meow2)

#load estuaries shape (where from)
estuaries <- sf::read_sf("./Estuaries2003/01_Data/14_001_UBC003_SAU_Estuaries2003_v2.shp")

#load countries data for inland/freshwater designation
countries <- ne_download(scale="large",type="countries",returnclass = "sf")


```

Custom function to find over which polygon record resides

```{r getinfo}
getRegionalInfo  <- function(lat1, long1, shape = meow) {
  #first, extract the co-ordinates (x,y - i.e., Longitude, Latitude)
  coords <- cbind(long1, lat1)
  
  df <-
    SpatialPointsDataFrame(coords, data.frame(value = paste(1:nrow(coords))))
  
  proj4string(df) <- CRS("+proj=longlat +datum=WGS84 +no_defs")
  
  
  df <- st_as_sf(df,
                    coords = c(x = "X", y = "Y"),
                    crs = "+proj=longlat +datum=WGS84 +no_defs")
  
  dsdat <- df %>% 
    st_join(shape)%>%
    mutate(dupl=duplicated(value))%>%
    filter(dupl==F)
 
  #due to simplification, records on shelf margin may be returned for both a MEOW and PEOW. Arbitrarily chose pelagic
  
  return(dsdat)
  
}



```


## Global marine species

### 
```{r mht}

#to make plotting faster
options(bitmapType = "cairo")
  
#map meows
 meow.map <- world.map2+
  geom_sf(data = meow%>%filter(TYPE=="MEOW"),fill="gray10",size = .2, alpha=1,inherit.aes = F)


#data table to speed up calculations

fb.gbif <- fb.dat%>%
  full_join(tibble(copy(gbif))%>%dplyr::select(species,decimalLatitude,decimalLongitude)%>%dplyr::rename(Species=species))%>%
  mutate(rec=1:nrow(.))%>%
  as.data.table()


#ID records as neritic with meow ecoregion or with biome from PPOW to find pelagics. Also pass through and inland based on shape data polygons
mht <-  fb.gbif[!is.na(decimalLatitude),{getRegionalInfo(lat1=decimalLatitude,long1 = decimalLongitude,shape=meow%>%dplyr::select(TYPE))%>%mutate(Species=Species,mar.fresh2=mar.fresh2,rec=rec)}]%>%  
  st_join(countries%>%dplyr::select(CONTINENT))%>% #is record inland
  st_join(estuaries%>%dplyr::select(LABEL))%>% #is record estuarine
  st_join(feow%>%dplyr::select(MHT_TXT)) #is record fw

#save mht data
saveRDS(list(mht=mht,map=meow.map,countries=countries),"mht.data.RDS")
```


```{r loadmht}
mht <- readRDS("mht.data.RDS")
```

Use occurence to designate MHT type and MHT, along with salinity, to designate halotolerance

```{r, salinity}
#back to datatable for speed
mht <- mht%>%data.table

#back to datatable for speed
mht2 <- head(mht,3000)


  
countries2 <- countries %>% 
  dplyr::group_by(CONTINENT) %>% 
  dplyr::summarise() %>% 
  sf::st_simplify(dTolerance = 1)


#distance to coastline
mht2[,dts:=st_distance(geometry,ne_coastline("medium","sf")) %>% set_units(., NULL)%>% as.vector(.) %>% min(.,na.rm=T),by=.(rec)]

mht2[,onland:=!is.na(as.numeric(st_intersects(geometry,countries%>%dplyr::select(CONTINENT)))),by=.(rec)]
mht2[,dts2:=ifelse(onland==T,dts*set_units(-1,m),dts)]



mht2 %>% 
  ggplot(aes(x=mar.fresh2,y=dts2))+geom_boxplot()

mht2 %>% 
  filter(mar.fresh2=="Fresh") %>% 
  ggplot(aes(x=dts2))+geom_histogram()

mht2[mar.fresh2=="Fresh"&onland==FALSE&dts>set_units(100e3,m)]

meow.map+ 
  stat_sf_coordinates(data = mht2[mar.fresh2=="Fresh"&onland==FALSE&dts>ggplot(aes(x=dts))+geom_histogram()], alpha=.1,inherit.aes = F,size=.3,aes(geometry=geometry),col="red")
hist(log(mht2$dts))

```

```{r mhtype}
#back to datatable for speed
mht <- mht%>%data.table

#many fw species are not designated so in FB. So use https://www.nature.com/articles/sdata2017141 to designate them as such.

fw.spp <- read_csv("FW_Occurrence_Table.csv")%>%
  mutate(Species=gsub("\\.", " ",Species.FB))%>%
  pull(Species)%>%unique()

mht[Species%in% fw.spp,mar.fresh2:="Fresh"]

#some marine species are inland, a problem with lat/lon data, so don't include in fresh MHT determinations. Also, exclude fresh from pelagic/neritic designatioons
mht[,MHT:=NA]
#oceanic
mht[mar.fresh2!="Fresh",MHT:=ifelse(TYPE=="PPOW","oceanic",NA)]
#neritic
mht[mar.fresh2!="Fresh",MHT:=ifelse(TYPE=="MEOW","neritic",MHT)]
#fw
mht[mar.fresh2!="Marine",MHT:=ifelse(!is.na(MHT_TXT),MHT_TXT,MHT)]
#estuarine
mht[,MHT:=ifelse(!is.na(LABEL),"neritic-est",MHT)]


## lots of marine NAs for MHT, look to be all neritic. A coverage issue with shape files
meow.map+ 
  stat_sf_coordinates(data = mht[is.na(MHT)&mar.fresh2=="Marine"], alpha=.1,inherit.aes = F,size=.3,aes(geometry=geometry),col="red")

#change to these to neritic, but exclude those with bogus lat/lon that place them inland
mht[is.na(MHT)&mar.fresh2=="Marine"&is.na(CONTINENT),MHT:="neritic"]


mht[,.(n=.N),by=.(mar.fresh2,MHT)]%>%
  ggplot(aes(x=MHT,y=n,group=mar.fresh2))+geom_col(position = "dodge",aes(fill=mar.fresh2))+ theme(axis.text.x = element_text(angle = 45, hjust = 1))

#seems some NAs for mar.fresh (salinity) are oceanic, change to marine
mht[is.na(mar.fresh2)&MHT=="oceanic",mar.fresh2:="Marine"]


## lots of Euryhaline NAs for MHT, look to be all neritic. A coverage issue with shape files
meow.map+ 
  stat_sf_coordinates(data = mht[is.na(MHT)&mar.fresh2=="Euryhaline"], alpha=.1,inherit.aes = F,size=.3,aes(geometry=geometry),col="red")

#change these to neritic
mht[is.na(MHT)&mar.fresh2=="Euryhaline",MHT:="neritic"]

#still some marine NAs, many have as coastal fw mht, give these nerit esturine designation 
mht[is.na(MHT)&mar.fresh2=="Marine" & grepl("coast",MHT_TXT),MHT:="neritic-est"]


#Still many NAs, seem to be mostly reef associated. time to add that
reef.sp <- fb.dat%>%filter(DemersPelag=="reefassociated")%>%pull(Species)
mht[is.na(MHT)&mar.fresh2=="Marine" & Species%in%reef.sp ,MHT:="neritic-reef"]

mht[is.na(MHT)]

#change fw mhts to lakes or rivers
mht[grepl("lake",MHT),MHT:="lakes"]
mht[grepl("river",MHT),MHT:="rivers"]

#what did we get
nrow(mht[!is.na(MHT)])/nrow(fb.gbif)
nrow(mht[!is.na(MHT),.(n=.N),by=Species])/n.sp

mht.sum <- mht[,.(n=.N),by=.(Species,mar.fresh2,MHT)][!is.na(MHT),.(pred.zone =MHT[which.max(n)],per=n[which.max(n)]/sum(n),n.tot=sum(n)),by=.(Species,mar.fresh2)]

nrow(mht.sum)/n.sp


View(mht[is.na(MHT) & !Species%in%mht.sum$Species])
mht[is.na(mar.fresh2),.(n=.N),by=Species]
```

#inland
mht[,MHT:=ifelse(!is.na(continent)&!is.na(LABEL),"inland",TYPE)]
  mutate(TYPE=ifelse(!is.na(continent)&!is.na(LABEL),"inland",TYPE))%>%
  mutate(TYPE=ifelse(is.na(continent)&!is.na(LABEL),"MEOW-est",TYPE))%>%
  filter(TYPE!="inland")


## must do st_joins on all shape files to get est and meow/peow data for all species

#filter out those that are inland
marine.pelner <- marine.sp2%>%
  st_join(countries)%>%
  st_join(estuaries)%>%
  mutate(TYPE=ifelse(!is.na(continent)&!is.na(LABEL),"inland",TYPE))%>%
  mutate(TYPE=ifelse(is.na(continent)&!is.na(LABEL),"MEOW-est",TYPE))%>%
  filter(TYPE!="inland")


#Check designations
meow.map+ 
  stat_sf_coordinates(data = marine.pelner, alpha=.1,inherit.aes = F,size=.3,aes(col=TYPE))

#82% of records can be classified 
nrow(marine.pelner%>%filter(!is.na(TYPE)))/nrow(marine.sp)

#summarize to get info on how many species can be designated
marine.pelner.sum <- marine.pelner%>%data.table()

 marine.pelner.sum <- marine.pelner.sum[,.(n=.N),by=.(Species,mar.fresh2,TYPE)][!is.na(TYPE),.(pred.zone =TYPE[which.max(n)],per=n[which.max(n)]/sum(n),n.tot=sum(n)),by=.(Species,mar.fresh2)]

#able to get 99% of marine species determined as pelagic or nericic
nrow(marine.pelner.sum[!is.na(pred.zone)])/marine.n

marine.pelner.sum[,.(n=.N),by=.(mar.fresh2,pred.zone)]%>%
  ggplot(aes(x=mar.fresh2,y=log(n),group=pred.zone))+geom_col(position = "dodge",aes(fill=pred.zone))

```

Didn't get some marine records as MEOW/PEOW. Seems most are right on the border of the MEOW/POEW boundaries

**repeat from above w estuaries***
```{r marnas}
#but what about those marine records that we didn't get
marine.nas <- marine.sp2%>%
  filter(is.na(ECOREGION),is.na(PROVINC),is.na(LABEL))

## looks like nearly all the marine species for which we don't have MEOW/PEOW data are neritic, but some are inland. Bad coordinates?
meow.map+
  stat_sf_coordinates(data = marine.nas, alpha=.05,inherit.aes = F,size=.1,col="red")



## so let's add an "MEOW" designation (neritic) for all marine records that are not inland (not in a country) and combine them with the records for which we did get MEOW/PEOW.
marine.nas <- marine.nas%>%st_join(countries)%>%
  st_join(countries)%>%
  st_join(estuaries)%>%
  mutate(TYPE=ifelse(!is.na(continent)&!is.na(LABEL),"inland",TYPE))%>%
  mutate(TYPE=ifelse(is.na(continent)&!is.na(LABEL),"MEOW-est",TYPE))%>%
  filter(TYPE!="inland")

#check data
meow.map+
  stat_sf_coordinates(data = marine.nas, alpha=.1,inherit.aes = F,size=.1,aes(col=TYPE))

#which marine species are inland
marine.nas2 <- marine.nas%>%copy%>%data.table()
marine.nas2[TYPE=="inland",.(n=.N),by=.(Species)]
```

Add marine species that are not inland to others that have MEOW/PEOW demonstration
```{r combmar}
marine.pelner2 <- marine.pelner%>%tibble%>%dplyr::select(Species,mar.fresh2,TYPE,geometry,rec)%>%
  rbind(marine.nas%>%tibble%>%dplyr::select(Species,mar.fresh2,TYPE,geometry,rec)%>%filter(mar.fresh2=="Marine",TYPE=="MEOW"))


## summarize to get coverage

marine.pelner.sum2 <- marine.pelner2%>%data.table()

 marine.pelner.sum2 <- marine.pelner.sum2[,.(n=.N),by=.(Species,mar.fresh2,TYPE)][!is.na(TYPE),.(pred.zone =TYPE[which.max(n)],per=n[which.max(n)]/sum(n),n.tot=sum(n)),by=.(Species,mar.fresh2)]
 
 #now 87% of marine records with a designation
 nrow(marine.pelner2)/nrow(marine.sp[mar.fresh2=="Marine"])

 
 #99% of marine species in rabosky tree, same as before but a more inclusive data set
  nrow(marine.pelner.sum2)/marine.n


marine.sp3 <- merge(marine.sp2%>%filter(rec%in%marine.pelner2$rec),marine.pelner.sum2[,.(Species,pred.zone)],by=c("Species"))


p.pelner <- meow.map+ 
  geom_sf(data =marine.sp3, alpha=.1,inherit.aes =F,size=.1,aes(col=pred.zone))

print(p.pelner)
```

Do the same for euryaline.

```{r euryprobs}
#But what about those euryhaline species (some could be oceanic, e.g. anguilla)

eury.sp <- fb.dat%>%
  full_join(tibble(copy(gbif))%>%dplyr::select(species,decimalLatitude,decimalLongitude)%>%rename(Species=species))%>%
  mutate(rec=1:nrow(.))%>%
  filter(mar.fresh2=="Euryhaline")%>%
  as.data.table()


world.map2+ 
  geom_point(data = eury.sp, alpha=.1,inherit.aes = F,size=.3,aes(x=decimalLongitude,y=decimalLatitude),col="red")



eury.n <- nrow(eury.sp[,.(.N),by=Species])


#use custom function to determine if occurrence is off the shelves (>200 m) in a PPOW
setkeyv(eury.sp,c("decimalLatitude","decimalLongitude"))

#ID records as neritic with meow ecoregion or with biome from PPOW to find pelagics
eury.sp2 <-  eury.sp[!is.na(decimalLatitude),{getRegionalInfo(lat1=decimalLatitude,long1 = decimalLongitude,shape=meow)%>%mutate(Species=Species,mar.fresh2=mar.fresh2,rec=rec)}]


 eury.pelner <- eury.sp2%>%
           mutate(pelagic.nerit:=ifelse(TYPE=="MEOW","neritic","pelagic"))

#filter out those that are inland
eury.pelner <- eury.pelner%>%st_join(countries)%>%
  mutate(TYPE=ifelse(!is.na(continent),"inland",TYPE))

#Check designations, missing many
meow.map+ 
  stat_sf_coordinates(data = eury.pelner%>%filter(is.na(TYPE)), alpha=.1,inherit.aes = F,size=.3,col="red")+coord_sf(xlim = c(-100, -77), ylim = c(25, 30), expand = FALSE)

#40.9857102,-70.6702252


#It appears again the designations are missing at the margins of coastal areas. Safe to call the neritic

#change NAs
eury.pelner <- eury.pelner %>%
  mutate(TYPE=ifelse(is.na(TYPE),"MEOW",TYPE))

meow.map+ 
  stat_sf_coordinates(data = eury.pelner, alpha=.1,inherit.aes = F,size=.3,aes(col=TYPE))


#99% of records can be classified 
nrow(eury.pelner)/nrow(eury.sp)



#summarize to get info on how many species can be designated
eury.pelner.sum <- eury.pelner%>%data.table()

 eury.pelner.sum <- eury.pelner.sum[,.(n=.N),by=.(Species,mar.fresh2,TYPE)][!is.na(TYPE),.(pred.zone=TYPE[which.max(n)],per=n[which.max(n)]/sum(n),n.tot=sum(n)),by=.(Species,mar.fresh2)]

#able to get 98% of Euryhaline species determined as pelagic, nericic or inland
nrow(eury.pelner.sum)/eury.n

```

```{r eurycomb}

eury.sp3 <- merge(eury.sp2%>%filter(rec%in%eury.pelner$rec),eury.pelner.sum[,.(Species,pred.zone)],by=c("Species"))


p.eury.pelner <- meow.map+ 
  geom_sf(data =eury.sp3, alpha=.1,inherit.aes =F,size=.1,aes(col=pred.zone))

print(p.eury.pelner)
```

Combine summaries of oceanic, neritic, inland designations for marine and euryhaline species.

```{r combpeldata}

mar.eury.pelner <- rbind(marine.pelner.sum,marine.pelner.sum2,eury.pelner.sum)



mar.eury.pelner[,pred.zone:=as.factor(pred.zone)]

levels(mar.eury.pelner$pred.zone) <- c("inland","neritic","oceanic")

mar.eury.pelner[,.(n=.N),by=.(mar.fresh2,pred.zone)]%>%
  ggplot(aes(x=mar.fresh2,y=log(n),group=pred.zone))+geom_col(position = "dodge",aes(fill=pred.zone))

```


Deep-sea and oceanic/pelagic species are a mess

load data first

```{r fishbasefix}


fb.eco <-ecology(fb.dat$Species)

fb.eco <-ecology(rob.sp) 

fb.eco <- fb.eco%>%
  select(Species,Neritic:Cave2,CoralReefs)

fb.eco[fb.eco == -1] <- 1

fb.eco <- fb.eco%>%
  pivot_longer(Neritic:CoralReefs,names_to="habitat",values_to="hab_value")%>%
  filter(hab_value==1)



```

## Create new broad habitat types 

Created from demersal-pelagic data, marine-fresh data, and habitat.

First, the fw habitats are a mess: mangroves when marshy (e.g., some Afr. killifishes), etc. Let's perform the same habitat assessment as pelagics using TNC's MHT data: https://geospatial.tnc.org/datasets/41aa8662254f43699e792fa194d7b3bb

```{r freshhab}

feow <- sf::read_sf("./FEOW-TNC/FEOWv1_TNC.shp") 

fb.dat%>%
  filter(mar.fresh2=="Fresh" & Species=="Polypterus bichir")
  
## also add euryhaline species that are inland
inland.sp <- mar.eury.pelner%>%filter(pred.zone=="inland")%>%pull(Species)

fw.sp <- fb.dat%>%
  full_join(gbif%>%dplyr::select(species,decimalLatitude,decimalLongitude)%>%rename(Species=species))%>%
  filter(mar.fresh2=="Fresh"|mar.fresh2=="Euryhaline"|Species%in%inland.sp)%>%
  mutate(rec=1:nrow(.))%>%
  as.data.table()

#use custom function to determine if occurrence is off the shelves (>200 m) in a PPOW
setkeyv(fw.sp,c("decimalLatitude","decimalLongitude"))

fw.mht<- fw.sp[!is.na(decimalLatitude),{getRegionalInfo(lat1=decimalLatitude,long1 = decimalLongitude,shape=feow)%>%mutate(Species=Species,mar.fresh2=mar.fresh2,rec=rec)}]

#seems the ones that many euryhaline records that were inland, were neritic

fw.mht%>%mutate(MHT_TXT=ifelse(is.na(MHT_TXT),"neritic",MHT_TXT))


world.map2+ 
  stat_sf_coordinates(data = fw.mht%>%filter(mar.fresh2=="Euryhaline"), alpha=.1,inherit.aes = F,size=.3,aes(col=MHT_TXT))+theme(legend.position="bottom")

nrow(fw.mht%>%filter(!is.na(MHT_TXT)))/nrow(fw.sp)

#retrieve mht for 81% of records

fw.mht.sum <- fw.mht%>%data.table()
fw.mht.sum <- fw.mht.sum[,.(n=.N),by=.(Species,MHT_TXT)][,.(pred.mht =MHT_TXT[which.max(n)],per=n[which.max(n)]/sum(n),n.tot=sum(n)),by=Species]



#we can classify 81% of inland/fw species
nrow(fw.mht.sum[!is.na(pred.mht)])/length(unique(fw.sp$Species))

View(fw.mht.sum[is.na(pred.mht)])

View(mar.eury.pelner%>%filter(pred.zone=="inland"))



```


```{r}
## for deep-sea fixes
deep.sea <- fb.dat%>%
  mutate(Genus=gsub("(\\w+) .+","\\1",Species))%>%
  left_join(fishbase,by = "Genus")%>%
  filter(DemersPelag%in%c("pelagicoceanic","bathypelagic","oceanic","bathydemersal"))%>%
  select(Species.x,Genus,Family,DemersPelag)%>%
  rename(Species=Species.x)%>%
  unique
  
#families classified as pelgicoceanic but are deep-sea (bathypelagic)
ds.fams <- c("Myctophidae","Bregmacerotidae","Stomiidae","Paralepididae","Sternoptychidae","Chiasmodontidae","Oneirodidae")


# cond1: If the habitat is oceanic, it can't be pelagic neritic, change to pelagicoceanic

# cond2: If the habitat is neritic, it can't be pelagicoceanic, change to pelagicneritic

# cond3: If the habitat is estuary and it's euryhaline, it can't be just pelagic, change to pelagicneritic

# cond4: Coryphaena hippurus is not pelagicneritic

#cond5: If habitat is bathypelagic, the DemersPelag can't be pelagicoceanic,e.g. Rhynchohyalus

#cond5: If the species is in the family Macrouridae, then it's bathydemersal (need ref for MS)

macrouridae <- deep.sea%>%filter(Family=="Macrouridae")%>%pull(Species)

#cond6: If the species the following families, then then it's bathypelagic (need ref for MS)

ds.change <- deep.sea%>%filter(Family%in%ds.fams)%>%pull(Species)

#cond7: If a marine species is within the neritic zone but both pelagicneritic and pelagicoceanic, go with pelagicneritic

#cond8: It's hard to make sense of the marine demersal vs. benthopelagic designations. Change to dermsal if benthopelagic.

#cond9: Latris lineata should be demersal

fb.eco3 <- fb.eco2%>%
  group_by(Species)%>%
  mutate(DemersPelag2=ifelse(grepl("Oceanic|Epipelagic",habitat) & DemersPelag=="pelagicneritic" & mar.fresh2=="Marine","pelagicoceanic",DemersPelag))%>% #cond1
  mutate(DemersPelag2=ifelse(grepl("Neritic",habitat) & DemersPelag=="pelagicoceanic",  "pelagicneritic",DemersPelag))%>%  #cond2
mutate(DemersPelag2=ifelse(grepl("Estuaries",habitat) & DemersPelag=="pelagic",  "pelagicneritic",DemersPelag))%>%#cond3
mutate(DemersPelag2=ifelse(Species=="Coryphaena hippurus","pelagicoceanic",DemersPelag))%>% #cond4
  mutate(DemersPelag2=ifelse(habitat=="bathypelagic" & DemersPelag=="pelagicoceanic","bathypelagic",DemersPelag))%>% #cond5
 mutate(DemersPelag2=ifelse(Species %in% macrouridae,"bathydemersal",DemersPelag))%>% #cond6
  mutate(DemersPelag2=ifelse(Species %in% ds.change,"bathypelagic",DemersPelag))

#cond7 (pelagics), change to dt for speed
pelagics <- fb.eco3%>%
  full_join(gbif%>%select(species,decimalLatitude,decimalLongitude)%>%rename(Species=species))%>%
  filter(mar.fresh2=="Marine",DemersPelag2%in%c("pelagicneritic","pelagicoceanic"))%>%
  as.data.table()

#use custom function to determine if occurrence is off the shelves (>200 m) in a PPOW
setkeyv(pelagics,c("decimalLatitude","decimalLongitude"))
pelagics[!is.na(decimalLatitude)&!is.na(decimalLongitude),PPOW:=getRegionalInfo(lat1=decimalLatitude,long1 = decimalLongitude)$ppo]
  
pelagic.sum <- pelagics[!is.na(PPOW),.(per.pelag=length(PPOW[PPOW==TRUE])/length(PPOW),n=.N),by=Species]

pelagic.sum[,DemersPelag3:=ifelse(per.pelag>0.75,"pelagicoceanic","pelagicneritic")]

#join pelagics analysis
fb.eco3 <- fb.eco3%>%
  full_join(tibble(pelagic.sum))


fb.eco3%>%
  ungroup()%>%
  filter(!is.na(DemersPelag3))%>%
  mutate(same=DemersPelag!=DemersPelag3)%>%
  summarise(per=length(same[same==FALSE])/length(same))

#only 63% of pelagic spp are classified correctly according to 75% of their occurrence records

# change DemersPelag2 to new pelagic level

fb.eco3 <- fb.eco3%>%
  mutate(DemersPelag2=ifelse(!is.na(DemersPelag3),DemersPelag3,DemersPelag2))


fb.eco3 <- fb.eco3%>%
  mutate(DemersPelag2=ifelse(DemersPelag2=="benthopelagic"& mar.fresh2=="Marine","demersal",DemersPelag2))%>% #cond8
  mutate(DemersPelag2=ifelse(Species=="Latris lineata","demersal",DemersPelag2))

#check marine data
fb.eco3%>%
  filter(mar.fresh2=="Marine")%>%
  ggplot(aes(x=DemersPelag2,y=log.L))+geom_boxplot()

```

## Create new broad habitat types 

Created from demersal-pelagic data, marine-fresh data, and habitat.

First, the fw habitats are a mess: mangroves when marshy (e.g., some Afr. killifishes), etc. Let's perform the same habitat assessment as pelagics using TNC's MHT data: https://geospatial.tnc.org/datasets/41aa8662254f43699e792fa194d7b3bb

```{r freshhab}

feow <- sf::read_sf("./FEOW-TNC/FEOWv1_TNC.shp") 

fb.eco3%>%
  filter(mar.fresh2=="Fresh" & Species=="Polypterus bichir")
  
fw.sp <- fb.eco3%>%
  full_join(gbif%>%select(species,decimalLatitude,decimalLongitude)%>%rename(Species=species))%>%
  filter(mar.fresh2=="Fresh")%>%
  as.data.table()

#use custom function to determine if occurrence is off the shelves (>200 m) in a PPOW
setkeyv(fw.sp,c("decimalLatitude","decimalLongitude"))
fw.sp[!is.na(decimalLatitude)&!is.na(decimalLongitude),mht:=getRegionalInfo(lat1=decimalLatitude,long1 = decimalLongitude,shape=feow)$mht]
  
nrow(fw.sp[!is.na(decimalLatitude)&!is.na(decimalLongitude)&is.na(mht)])/nrow(fw.sp)

#less than 1% missing mht

fw.sp.sum <- fw.sp[,.(n=.N),by=.(Species,mht)][!is.na(mht),.(pred.mht =mht[which.max(n)]),by=Species]
#mangrove issue

unique(fw.sp.sum$pred.mht)
fb.eco3%>%
  filter(habitat=="Mangroves", mar.fresh2=="Fresh")%>%
  View

lk.str <- c("lakes","stream")
fb.eco3%>%
  group_by(Species)%>%
  mutate(habitat2=ifelse(mar.fresh2=="fresh" & all(habitat))
```


gbif[,l.l.m := paste0(lat2,"_",lon2,"_",month)]

#store depth interval from temp depth data


gbif[,':='(l.l.m.d = paste0(lat2,"_",lon2,"_",month,"_",int),
                                 l.l = paste0(lat2,"_",lon2)
                                 )] #Identifier for  lat lon month depth



t.depth[,lon := sapply(lon,degEtoLon)]

#add same levels as above
t.depth[,':='(l.l.m.d = paste0(lat,"_",lon,"_",time,"_",depth),
              l.l.d = paste0(lat,"_",lon,"_",depth))]

setkey(gbif,l.l.m.d)
setkey(t.depth,l.l.m.d)

#merge data tables for temp and depth (marine ) temp range
gbif.eco<- merge(gbif,t.depth[,.(l.l.m.d,value)],by="l.l.m.d",all.y=F,all.x=T)
colnames(gbif.eco)[colnames(gbif.eco)=="depth"] <- "depth.gbif"
colnames(gbif.eco)[colnames(gbif.eco)=="value"] <- "tdepth"
colnames(gbif.eco)[colnames(gbif.eco)=="name"] <- "Sciname" #fix ccol names for merging


gbif.m <- gbif.dat[,.(m.depth=mean(depth.gbif,na.rm=T),m.temp=mean(tdepth,na.rm=T),lat=mean(lat2,na.rm=T),lon=mean(lon2,na.rm=T)),by=.(scientificName)]

ggplot(world, aes(long, lat)) +geom_polygon(aes(group = group), fill = "white", color = "gray40", size = .2) + geom_point(data = gbif.dat[!is.na(tdepth)],aes(x=lon2, y=lat2,col=tdepth), alpha=1,inherit.aes = F) +scale_color_viridis(
    option = "magma",
    name = "US T_depth",
    discrete = F,
    direction = 1,
    guide = guide_legend(
     title.position = 'top',
     reverse = F,
  ))


qplot(data=gbif.m,m.depth,m.temp,col=abs(lat))


```


add upstream data to fb data.
```{r mergefb}

fb.dat <- readRDS("fishbase.data.RDS")

upstream.dat[,l.l := paste0(y,"_",x)]#Identifier for  lat (y) lon (x)

#Add species column
gbif.dat[,Species:=gsub("(\\w+ \\w+) .+","\\1",scientificName[1])]
fb.eco.dat<- merge(gbif.dat,fb.dat,by="Species",all.y=F,all.x=T)

# Add upstream min, max and range
fb.eco.dat <- merge(fb.eco.dat,upstream.dat,by="l.l",all.y=F)


### Add sst dat

#must change sst  lon from 0-360 to -180-180
# long is in degress E
sst.dat[,lon := sapply(lon,degEtoLon)]

sst.dat[,l.l.m := paste0(lat,"_",lon,"_",time)]

fb.eco.dat[,l.l.m := paste0(lat2,"_",lon2,"_",month)]


fb.eco.dat <- merge(fb.eco.dat,sst.dat,by="l.l.m",all.x=T)

fb.eco.dat[,temp2:=ifelse(mar.fresh2=="Freshwater",mean,m.sst)]
fb.eco.dat[is.na(m.sst),temp2:=tdepth]

fb.eco.dat[!is.na(temp2),.(n=length(temp2)),by=.(scientificName)]
#merging fb and gbif data. need gbif for marine month and temp, fb for freshwater/marine 
#freshwater
fb.eco.dat[,':='(mean.min=mean.min/10,
                 mean.max=mean.max/10,
                 t.range=t.range/10)]

```
#mean per lld
t.depth2 <- t.depth[,.(tdepth=mean(value)),by=l.l.d]

fb.dat[,int:=sapply(depth.max,function(x)4 ifelse(is.na(x)==F,depth.int[which.min(abs(depth.int-x))],NA))]

fb.dat[,l.l.d := paste0(lat2,"_",lon2,"_",int)] #Identifier for  lat lon month depth

fb.dat <- merge(fb.dat,t.depth2,by="l.l.d",all.y=F,all.x=T) #merge with tdepth [here] why are some values missing for marine species with good lat lon and depth
colnames(fb.dat)[colnames(fb.dat)=="value"] <- "tdepth"

write.csv(fb.dat,"fb.lat.lon.temp.dat.csv")


#inspect data, looks good
qplot(lat2,tdepth,dat=fb.dat)

#columns for analysis
col.anal <- .(Sciname,mdpt.range,lon2,lat2,month,depth,region.marfresh,marine.fresh,water.column,depth.range,region)
#marine
gbif.dat2 <- gbif.dat[,.(Sciname,lon2,lat2,mdpt.range,month,depth.gbif,region.marfresh,marine.fresh,water.column,depth.range,region,l.l,l.l.m.d)]
gbif.dat2[,database:="gbif"]
fb.length <- fb.dat[,.(Sciname,Length)]
#DT[,.(V4.Sum = sum(V4)),by=V1]
fb.length <- fb.dat[,.(length=mean(Length)),by=Sciname]




gbif.dat2<- merge(gbif.dat2,fb.length,by="Sciname",all.y=F)
colnames(gbif.dat2)[colnames(gbif.dat2)=="l.l.m.d.1"] <- "l.l.m.d"

gbif.dat2 <- merge(gbif.dat2,t.depth,by="l.l.m.d",all.y=F)
colnames(gbif.dat2)[colnames(gbif.dat2)=="depth.gbif"] <- "depth"
colnames(gbif.dat2)[colnames(gbif.dat2)=="value"] <- "tdepth"

gbif.dat3 <- gbif.dat2[,.(Sciname,mdpt.range,lon2,lat2,length,month,depth,region.marfresh,marine.fresh,water.column,depth.range,region,tdepth,database)]
#inspect data, looks good
qplot(lat2,tdepth,dat=gbif.dat2)

gbif.datD <- gbif.dat3[,.(depth.m=mean(depth, na.rm=T)),by=Sciname]
fb.datD <- fb.dat2[,.(depth.m=mean(depth.max, na.rm=T)),by=Sciname]
fb.datD[!is.nan(fb.datD$depth.m),]
fb.dat2
nrow(gbif.datD)

write.csv(gbif.dat3,"gbif3.lat.lon.temp.dat.csv")

#merge gbif and fb data (here)
fb.dat2 <- fb.dat[,.(Sciname,mdpt.range,lon2,lat2,Length,region.marfresh,marine.fresh,water.column,depth.range,depth.max,region,database,t.range,t.mean,mean.min,mean.max,tdepth)]

colnames(fb.dat2)[colnames(fb.dat2)=="Length"] <- "length"
setdiff(colnames(fb.dat2),colnames(gbif.dat3))


#set dummy columns for missing
#DT[, c("V1","V2") := list(round(exp(V1),2), LETTERS[4:6])]

fb.dat2[,setdiff(colnames(gbif.dat3),colnames(fb.dat2)) :=NA]
gbif.dat3[,setdiff(colnames(fb.dat2),colnames(gbif.dat3)) :=NA]

#bind fb and gbif dat
fb.gbif.dat <- rbind(fb.dat2,gbif.dat3)
colnames(fb.gbif.dat)[colnames(fb.gbif.dat)=="length"] <- "Length"

write.csv(fb.gbif.dat,"fb.gbif.lat.lon.temp.dat.csv")

qplot(lat2,tdepth,dat=fb.gbif.dat,col=water.column)+facet_grid(.~database)

#DT[, c("V1","V2") := list(round(exp(V1),2), LETTERS[4:6])]

#temp1 = max temp from all calcs, temp2 = min, temp3=range,[here]


#DT[,.(V4.Sum = sum(V4)),by=V1]
fb.gbif.mean <- fb.gbif.dat[,.(
  temp1=mean(c(tdepth,mean.max),na.rm=T),
  temp2=mean(c(tdepth,mean.min),na.rm=T),
  mean.lat=mean(lat2),
  depth=max(c(depth,depth.max),na.rm=T),
  water.column=unique(water.column),
  sd.temp=sd(c(tdepth,mean.max),na.rm=T),
  temp.range=diff(range(c(tdepth,mean.max,mean.min),na.rm=T)),
  mar.fresh=unique(marine.fresh),depth=mean(c(depth.max,depth),na.rm=T),
  length.temp=length(c(tdepth,mean.max)),
  Length=mean(Length),
  region=unique(region)),
  by=Sciname]

fb.gbif.mean[,log.l:=log(Length)]

fb.gbif.mean <- replace(fb.gbif.mean, is.na(fb.gbif.mean), NA)#replace NaN with NA
invisible(lapply(names(fb.gbif.mean),function(.name) set(fb.gbif.mean, which(is.infinite(fb.gbif.mean[[.name]])), j = .name,value =NA)))#replace Inf with NA

fb.gbif.mean$depth[fb.gbif.mean$mar.fresh=="Freshwater"]
dat.stats <- sapply(fb.gbif.mean,function(x) length(x[!is.na(x)]))

write.csv(dat.stats,"length.vars.fb.gbif.csv")

#plot means ofl vs temp.range
qplot(temp.range,log.l,dat=fb.gbif.mean)+facet_grid(.~water.column)+geom_smooth(aes(temp.range,log.l),data=fb.gbif.mean,method = "lm")

anova(lm(log.l~temp.range+water.column,fb.gbif.mean))

eco.dat <- as.data.frame(fb.gbif.mean)
rownames(eco.dat) <- eco.dat$Sciname

eco.tree <- drop.tip(bet.cal.tree,setdiff(bet.cal.tree$tip.label,eco.dat$Sciname))

write.tree(eco.tree,"bet.eco.tree")
write.csv(eco.dat,"eco.dat.csv") #final values for comparative analysis

write.csv(fb.gbif.mean,"fb.gbif.dat.csv") #


```

### papers to cite

https://www.int-res.com/articles/feature/m405p001.pdf
